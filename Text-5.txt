(* [colour] is the type representing
 conventional colours. These are defined as
 red, blue, green, yellow, purple, pink and black.*)
type colour

(* [compare c1 c2] is -1 if [c1] is less than [c2],
 * 0 if [c1] is equal to [c2], or 1 if [c1] is
 * greater than [c2]. *)
val compare_colours : colour -> colour -> int

(* [colorify str] is str represented as a colour.
 requires:
 - [str] may only be one of the following
 'red', 'blue', 'green', 'yellow', 'purple', 'pink', 'black' *)
val colorify : string -> colour

(* [decolorify c] is colour represented as
a lowercase str. *)
val decolorify : colour -> string

==========================================
Reasons for use:
- Rather than passing around strings to represents colour,
code has a better chance of being error-free if a fixed
set of variants were to be used.
- Functions added allow for these colours to be
decoded and added to files as necssary.



(* [t] is a type representing the annotations,
ie: highlights, notes and bookmark in/of a given
page. *)
type t

(* [get_page_overlay book it1 t1] is [t] for
annotations present in [book] between the starting (s)
and ending index (t), inclusive. [it1] is (s,t) *)
val get_page_overlay : string -> int * int -> t

(* [add_note note it1 t1] is [t2] with a note added
between the starting (s) and ending index (t), inclusive.
[it1] is (s,t) *)
val add_note : string -> int * int -> t -> t

(* [notes t1] is [slst], representing
the list of all notes and the indices each are in,
present in the page denoted by [t1] *)
val notes : t -> (int * int) * string list

(* [add_highlight it1 c1 t1] is [t2] with a highlight of colour
c1 added between the starting (s) and ending index (t), inclusive.
[it1] is (s,t) *)
val add_highlight : int * int -> colour -> t -> t

(* [highlights t1 it1] is [hlst], representing
the list of indice ranges and the colour of highlights
for each.*)
val highlights : t -> (int * int) * colour list

(* [is_bookmarked t1] is [true] if the page [t1]
refers to is bookmarked. [false] otherwise. *)
val is_bookmarked : t -> bool 

(* [add_bookmark t1 c1] is [t2] with the page [t1]
bookmarked with colour [c1]. [false] otherwise. *)
val add_bookmark : t -> colour -> bool

(* [bookmarks book] returns the list of bookmarks
associated with the book of title [book]. *)
val bookmarks : string -> (int * int) * colour list

====================================
Summary:
Represents the additions on a page (overlay). Allows for changes
to this structure and updates JSON files.
To Add:
- Would it be better to use variants to make highlights and notes easier
to match against
- int * int is a terrible way to actually measure pages or lines or anything,
there has to be a better way to do it.
- page -> what does that mean

(*how do we keep track of bookmarked pages though because these could keep changing,
so bookmarks are useless in this sense.*)


open Marginalia
open QA

(* [t] represents a type of multiple pages. *)
type t 

(* [update_page_range it1 i] is [t] with the page represented by
[it1] present along with i consecutive pages.*)
val update_page_range : int * int -> int -> t

val page_annotations : t -> [> H of ]

val skim : t -> 

(* [flash_card str] is a list of strings, present as annotations,
relevant to the given term [str] and the indices at which these strings
begin and end. *)
val flash_card : string -> (int * int) * string list

(* [search_notes str] is a list of the beginning
and ending of notes that contain the term [str].*)
val search_notes : string -> int * int list

(* [question qa str] is the id of the corresponding
question or answer [str] stored in the QA database.
[qa] represents the type of the statement being added
of type QA.t' *)
val question : QA.t' -> string -> int

===============================================================
Summary: Structure that keeps track of the pages within a
certain range. Allows ebook features to be created from this
information.

Design Considerations:
- JSON interactions
 1. Pull from JSON file each time note, question or highlight is asked for.
 2. Pull all data when the book is opened, create add each to a data structure to use.
 (I) Efficiency:
     Pulling all at once is definitely expensive. Creating a data structure for the annotations
		 in the entire book is needless, especially if one is not going to read the entire book.
		 Pull it one by one is also not a good idea because might need to use annotations across different
		 pages so we can't just keep pulling data.
		 IDEA: Create a data structure containing annotations within a certain range of the current page.
		       Update in JSON and data structure everytime changes are made.
 (II) Would make search easier, instead of searching in the JSON file.
	
	Question: Does it make sense for it not to have the entire book, only a subset.
					 
	IMPLEMENTATION: Linkedlist?

Simple features:
- giving notes and highlights on a page as record
- search based notes

Advanced features:
- simple flip, notes on preceding pages related to the topic (how though)
- flash cards : content based organized notes

(* [t'] represents either a Question (Q) or
Answer (A)*)
type t' = Q | A
  
(* [post t1 str] is [true] if the
statement [str] is added as a question
or answer [t1] to the database.
[false] otherwise.*)
val post : t' -> string -> bool

(* [post t1 i] is [str], the question or answer
with id [i] in the database. [t1] determines
whether the retrieved [str] is a question
or answer.*)
val get : t' -> int -> string 

(* [delete t1 i] is [true], if the the question or answer
with id [i] is successfully deleted from the database.
[t1] determines whether the retrieved [str] is a question
or answer.*)
val delete : t' -> int -> bool

(* [question_list ()] is the list of question present in the given
database and id's they correspond too.*)
val question_list : unit -> int * string list

====================================
TODO:
How do you recognize what each question is
if its encapsulated
How to post to a specific server/db?
How are we getting answers to related questions

